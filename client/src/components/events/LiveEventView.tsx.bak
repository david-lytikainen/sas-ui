import React, { useState, useEffect, useContext } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
  Box,
  Typography,
  Paper,
  Grid,
  Card,
  CardContent,
  CircularProgress,
  Alert,
  Chip,
  Button,
  Divider,
  Avatar,
  Stack,
  LinearProgress,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Tooltip,
  IconButton,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Tabs,
  Tab,
  FormControl,
  FormControlLabel,
  RadioGroup,
  Radio,
  Container,
  Select,
  MenuItem,
  InputLabel,
} from '@mui/material';
import {
  AccessTime as TimeIcon,
  Person as PersonIcon,
  TableBar as TableIcon,
  EventSeat as SeatIcon,
  Favorite as HeartIcon,
  Check as CheckIcon,
  HourglassTop as HourglassIcon,
  ArrowBack as ArrowBackIcon,
  Pause as PauseIcon,
  PlayArrow as PlayIcon,
  Edit as EditIcon,
  Settings as SettingsIcon,
  ViewList as ViewListIcon,
  ViewModule as ViewModuleIcon,
  SupervisorAccount as SupervisorAccountIcon,
  People as PeopleIcon,
} from '@mui/icons-material';
import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';
import { LocalizationProvider, DateTimePicker } from '@mui/x-date-pickers';
import { eventsApi } from '../../services/api';
import { useAuth } from '../../context/AuthContext';
import { useEvents } from '../../context/EventContext';

// Define interfaces
interface ScheduleItem {
  id: string;
  eventId: string;
  participant1Id: string;
  participant2Id: string;
  startTime: string;
  endTime: string;
  tableNumber: number;
  status: 'upcoming' | 'current' | 'completed' | 'paused';
  isPaused?: boolean;
}

interface Match {
  id: string;
  eventId: string;
  participant1Id: string;
  participant2Id: string;
  compatibilityScore: number;
  createdAt: string;
}

interface Participant {
  id: string;
  user_id: string;
  event_id: string;
  first_name: string;
  last_name: string;
  email: string;
  phone: string;
  status: 'registered' | 'checked_in' | 'cancelled';
  registration_date: string;
  check_in_time?: string;
}

interface Event {
  id: string;
  creator_id: string;
  starts_at: string;
  ends_at: string;
  address: string;
  name: string;
  max_capacity: number;
  status: 'draft' | 'published' | 'cancelled' | 'completed' | 'in_progress';
  price_per_person: number;
  registration_deadline: string;
  description: string;
  updated_at: string;
  created_at: string;
}

const LiveEventView: React.FC = () => {
  const { eventId } = useParams<{ eventId: string }>();
  const navigate = useNavigate();
  const { user, isAdmin: authIsAdmin, isOrganizer: authIsOrganizer } = useAuth();
  const { refreshEvents } = useEvents();
  
  const [event, setEvent] = useState<Event | null>(null);
  const [schedule, setSchedule] = useState<ScheduleItem[]>([]);
  const [matches, setMatches] = useState<Match[]>([]);
  const [participants, setParticipants] = useState<Participant[]>([]);
  const [participantsMap, setParticipantsMap] = useState<Record<string, Participant>>({});
  
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [currentRound, setCurrentRound] = useState<ScheduleItem | null>(null);
  const [nextRound, setNextRound] = useState<ScheduleItem | null>(null);
  const [timeRemaining, setTimeRemaining] = useState<string>('');
  const [progressPercent, setProgressPercent] = useState(0);
  const [activeTab, setActiveTab] = useState<'schedule' | 'matches'>('schedule');
  const [isPaused, setIsPaused] = useState(false);
  const [viewMode, setViewMode] = useState<'list' | 'grid'>('list');
  
  // Dialog states
  const [editDialogOpen, setEditDialogOpen] = useState(false);
  const [fullScheduleDialogOpen, setFullScheduleDialogOpen] = useState(false);
  const [selectedRound, setSelectedRound] = useState<ScheduleItem | null>(null);
  const [editStartTime, setEditStartTime] = useState<Date | null>(null);
  const [editEndTime, setEditEndTime] = useState<Date | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  const [scheduleDuration, setScheduleDuration] = useState(5); // Default 5 minutes per round
  const [breakDuration, setBreakDuration] = useState(2); // Default 2 minutes break

  // Add new state variables for the full schedule management
  const [adjustTimeDialogOpen, setAdjustTimeDialogOpen] = useState(false);
  const [selectedRoundIndex, setSelectedRoundIndex] = useState<number>(-1);
  const [adjustTimeValue, setAdjustTimeValue] = useState<Date | null>(null);
  const [shiftMode, setShiftMode] = useState<'single' | 'all_subsequent'>('all_subsequent');

  // Add a loader notification for when the event is first started
  const [isNewEvent, setIsNewEvent] = useState(false);

  // Event management states and functions
  const [isLoadingControl, setIsLoadingControl] = useState(false);
  const [controlError, setControlError] = useState('');
  const [currentRoundId, setCurrentRoundId] = useState<string | null>(null);

  // Helpers to check roles
  const checkIsAdmin = () => {
    return authIsAdmin();
  };
  
  const checkIsOrganizer = () => {
    return event && authIsOrganizer(event.creator_id);
  };

  const canManageEvent = checkIsAdmin() || checkIsOrganizer();

  // Load event data, schedule, matches and participants
  useEffect(() => {
    const fetchEventData = async () => {
      if (!eventId) return;
      
      setLoading(true);
      setError(null);
      
      try {
        // Fetch event
        const eventData = await eventsApi.getEvent(eventId);
        setEvent(eventData);
        
        // Check for newly started event
        const isJustStarted = eventData.status === 'in_progress' && 
                             (new Date().getTime() - new Date(eventData.updated_at).getTime()) < 10000; // Within 10s
        if (isJustStarted) {
          setIsNewEvent(true);
        }
        
        // Check if event is in progress
        if (eventData.status !== 'in_progress') {
          if (eventData.status === 'completed') {
            setError('This event has ended. You can view completed events in the Archive tab.');
          } else {
            setError(`This event is not currently live (Status: ${eventData.status.toUpperCase()})`);
          }
          setLoading(false);
          return;
        }
        
        // Fetch schedule
        const scheduleData = await eventsApi.getEventSchedule(eventId);
        
        // Handle case when schedule is empty but event is in progress
        if (scheduleData.length === 0) {
          // This might be a new event, try to generate schedule
          if (isJustStarted) {
            // Fetch participants
            const participantsData = await eventsApi.getEventParticipants(eventId);
            const checkedInParticipants = participantsData.filter((p: Participant) => p.status === 'checked_in');
            
            // If we have participants but no schedule, try running the matching
            if (checkedInParticipants.length >= 2) {
              await eventsApi.runMatching(eventId);
              // Re-fetch schedule
              const newScheduleData = await eventsApi.getEventSchedule(eventId);
              setSchedule(newScheduleData);
            }
          } else {
            // Just set empty schedule if not new event
            setSchedule([]);
          }
        } else {
          // We have a schedule, set it
          setSchedule(scheduleData);
        }
        
        // Fetch participants
        const participantsData = await eventsApi.getEventParticipants(eventId);
        
        // Filter to only include checked-in participants
        const checkedInParticipants = participantsData.filter((p: Participant) => p.status === 'checked_in');
        setParticipants(checkedInParticipants);
        
        // Create participants map for easier lookup
        const participantsMapData: Record<string, Participant> = {};
        checkedInParticipants.forEach((participant: Participant) => {
          participantsMapData[participant.id] = participant;
        });
        setParticipantsMap(participantsMapData);
        
      } catch (err: any) {
        setError(err.message || 'Failed to load event data');
        console.error('Error fetching event data:', err);
      } finally {
        setLoading(false);
      }
    };
    
    fetchEventData();
  }, [eventId]);
  
  // Add an auto-refresh for newly started events
  useEffect(() => {
    let refreshTimer: NodeJS.Timeout | null = null;
    
    if (isNewEvent) {
      // Set a timer to refresh data after 2 seconds
      refreshTimer = setTimeout(async () => {
        try {
          // Re-fetch schedule 
          const scheduleData = await eventsApi.getEventSchedule(eventId!);
          if (scheduleData.length > 0) {
            setSchedule(scheduleData);
          }
          setIsNewEvent(false);
        } catch (error) {
          console.error('Error refreshing schedule:', error);
        }
      }, 2000);
    }
    
    return () => {
      if (refreshTimer) {
        clearTimeout(refreshTimer);
      }
    };
  }, [isNewEvent, eventId]);

  // Update timer and determine current/next round
  useEffect(() => {
    if (schedule.length === 0) return;
    
    const timerInterval = setInterval(() => {
      const now = new Date();
      
      // Update schedule items status
      const updatedSchedule = schedule.map(item => {
        // Skip updates if round is paused
        if (item.status === 'paused' as const) {
          return item;
        }
        
        const startTime = new Date(item.startTime);
        const endTime = new Date(item.endTime);
        
        if (now >= startTime && now < endTime) {
          return { ...item, status: 'current' as const };
        } else if (now >= endTime) {
          return { ...item, status: 'completed' as const };
        } else {
          return { ...item, status: 'upcoming' as const };
        }
      });
      
      // Find current round
      const current = updatedSchedule.find(item => item.status === 'current');
      setCurrentRound(current || null);
      
      // Find next round
      const upcoming = updatedSchedule
        .filter(item => item.status === 'upcoming')
        .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());
      setNextRound(upcoming.length > 0 ? upcoming[0] : null);
      
      // Calculate time remaining or progress
      if (current) {
        const endTime = new Date(current.endTime).getTime();
        const startTime = new Date(current.startTime).getTime();
        const totalDuration = endTime - startTime;
        const elapsed = now.getTime() - startTime;
        const remaining = endTime - now.getTime();
        
        // Calculate progress percentage
        const progress = Math.floor((elapsed / totalDuration) * 100);
        setProgressPercent(Math.min(100, Math.max(0, progress)));
        
        // Format remaining time
        const minutes = Math.floor(remaining / (1000 * 60));
        const seconds = Math.floor((remaining % (1000 * 60)) / 1000);
        setTimeRemaining(`${minutes}m ${seconds}s remaining`);
      } else if (upcoming.length > 0) {
        const startTime = new Date(upcoming[0].startTime).getTime();
        const waitTime = startTime - now.getTime();
        
        if (waitTime > 0) {
          const minutes = Math.floor(waitTime / (1000 * 60));
          const seconds = Math.floor((waitTime % (1000 * 60)) / 1000);
          setTimeRemaining(`Next round in ${minutes}m ${seconds}s`);
        } else {
          setTimeRemaining('Starting now');
        }
        
        setProgressPercent(0);
      } else {
        setTimeRemaining('Event complete');
        setProgressPercent(100);
      }
      
      // Update the schedule with new statuses
      setSchedule(updatedSchedule);
      
    }, 1000);
    
    return () => clearInterval(timerInterval);
  }, [schedule]);

  // Handle pausing a round
  const handlePauseRound = (roundId: string) => {
    const updatedSchedule = schedule.map(item => {
      if (item.id === roundId) {
        return { ...item, status: 'paused' as const };
      }
      return item;
    });
    
    setSchedule(updatedSchedule);
    
    // If the current round is being paused, update its state
    if (currentRound && currentRound.id === roundId) {
      setCurrentRound({ ...currentRound, status: 'paused' as const });
      setIsPaused(true);
    }
    
    // Show success message
    setSuccessMessage('Round paused successfully');
    setTimeout(() => setSuccessMessage(null), 3000);
  };

  // Handle resuming a round
  const handleResumeRound = (roundId: string) => {
    const now = new Date();
    
    // Get the paused round
    const pausedRound = schedule.find(item => item.id === roundId);
    if (!pausedRound) return;
    
    // Calculate the new end time based on the remaining duration
    const originalStartTime = new Date(pausedRound.startTime);
    const originalEndTime = new Date(pausedRound.endTime);
    const originalDuration = originalEndTime.getTime() - originalStartTime.getTime();
    
    // Set new end time to be now + original duration
    const newEndTime = new Date(now.getTime() + originalDuration);
    
    // Calculate time shift for subsequent rounds
    const timeShift = now.getTime() - originalStartTime.getTime();
    
    // Get index of the paused round
    const pausedRoundIndex = schedule.findIndex(item => item.id === roundId);
    
    // Update the schedule
    const updatedSchedule = schedule.map((item, index) => {
      if (item.id === roundId) {
        return { 
          ...item, 
          status: 'current' as const,
          startTime: now.toISOString(),
          endTime: newEndTime.toISOString()
        };
      }
      
      // Shift all subsequent rounds
      if (index > pausedRoundIndex) {
        const itemStartTime = new Date(item.startTime).getTime();
        const itemEndTime = new Date(item.endTime).getTime();
        const itemDuration = itemEndTime - itemStartTime;
        
        const newStart = new Date(itemStartTime + timeShift);
        const newEnd = new Date(newStart.getTime() + itemDuration);
        
        return {
          ...item,
          startTime: newStart.toISOString(),
          endTime: newEnd.toISOString()
        };
      }
      
      return item;
    });
    
    setSchedule(updatedSchedule);
    
    // Update current round if it's the one being resumed
    if (pausedRound.id === roundId) {
      setCurrentRound({ 
        ...pausedRound, 
        status: 'current' as const,
        startTime: now.toISOString(),
        endTime: newEndTime.toISOString()
      });
      setIsPaused(false);
    }
    
    // Show success message
    setSuccessMessage('Round resumed and subsequent rounds shifted');
    setTimeout(() => setSuccessMessage(null), 3000);
  };

  // Handle opening the edit dialog
  const handleEditRound = (round: ScheduleItem) => {
    setSelectedRound(round);
    setEditStartTime(new Date(round.startTime));
    setEditEndTime(new Date(round.endTime));
    setEditDialogOpen(true);
  };

  // Handle saving the edited round times
  const handleSaveRoundTimes = () => {
    if (!selectedRound || !editStartTime || !editEndTime) return;
    
    // Update the schedule with the new times
    const updatedSchedule = schedule.map(item => {
      if (item.id === selectedRound.id) {
        return { 
          ...item, 
          startTime: editStartTime.toISOString(),
          endTime: editEndTime.toISOString()
        };
      }
      return item;
    });
    
    setSchedule(updatedSchedule);
    
    // If this is the current or next round, update those states too
    if (currentRound && currentRound.id === selectedRound.id) {
      setCurrentRound({ 
        ...currentRound, 
        startTime: editStartTime.toISOString(),
        endTime: editEndTime.toISOString()
      });
    }
    
    if (nextRound && nextRound.id === selectedRound.id) {
      setNextRound({ 
        ...nextRound, 
        startTime: editStartTime.toISOString(),
        endTime: editEndTime.toISOString()
      });
    }
    
    // Close dialog and show success message
    setEditDialogOpen(false);
    setSuccessMessage('Round times updated successfully');
    setTimeout(() => setSuccessMessage(null), 3000);
  };

  const formatTime = (dateString: string) => {
    return new Date(dateString).toLocaleTimeString('en-US', {
      hour: '2-digit',
      minute: '2-digit',
    });
  };
  
  const getParticipantName = (participantId: string) => {
    if (!participantsMap[participantId]) return 'Unknown';
    return `${participantsMap[participantId].first_name} ${participantsMap[participantId].last_name}`;
  };
  
  const getStatusColor = (status: 'upcoming' | 'current' | 'completed' | 'paused') => {
    switch (status) {
      case 'current':
        return 'success';
      case 'upcoming':
        return 'primary';
      case 'completed':
        return 'default';
      case 'paused':
        return 'warning';
      default:
        return 'default';
    }
  };
  
  const getStatusIcon = (status: 'upcoming' | 'current' | 'completed' | 'paused') => {
    switch (status) {
      case 'current':
        return <CheckIcon />;
      case 'upcoming':
        return <HourglassIcon />;
      case 'completed':
        return <CheckIcon />;
      case 'paused':
        return <PauseIcon />;
      default:
        return <HourglassIcon />;
    }
  };

  // Handle generating a completely new schedule
  const handleGenerateNewSchedule = () => {
    if (!event || participants.length < 2) return;
    
    // Get event start and end times
    const eventStart = new Date(event.starts_at);
    const eventEnd = new Date(event.ends_at);
    const totalDuration = eventEnd.getTime() - eventStart.getTime();
    
    // Calculate how many rounds we can fit
    const roundTimeMs = scheduleDuration * 60 * 1000;
    const breakTimeMs = breakDuration * 60 * 1000;
    const cycleTimeMs = roundTimeMs + breakTimeMs;
    const maxRounds = Math.floor(totalDuration / cycleTimeMs);
    
    // Get all possible pairs of participants
    const pairs: [Participant, Participant][] = [];
    for (let i = 0; i < participants.length; i++) {
      for (let j = i + 1; j < participants.length; j++) {
        pairs.push([participants[i], participants[j]]);
      }
    }
    
    // Shuffle pairs to create randomness
    const shuffledPairs = [...pairs].sort(() => Math.random() - 0.5);
    
    // Create the new schedule
    const newSchedule: ScheduleItem[] = [];
    const pairsToUse = shuffledPairs.slice(0, maxRounds);
    
    pairsToUse.forEach((pair, index) => {
      const roundStartTime = new Date(eventStart.getTime() + index * cycleTimeMs);
      const roundEndTime = new Date(roundStartTime.getTime() + roundTimeMs);
      
      newSchedule.push({
        id: `round-${index + 1}`,
        eventId: eventId!,
        participant1Id: pair[0].id,
        participant2Id: pair[1].id,
        startTime: roundStartTime.toISOString(),
        endTime: roundEndTime.toISOString(),
        tableNumber: (index % Math.ceil(participants.length / 2)) + 1,
        status: new Date() >= roundStartTime && new Date() < roundEndTime 
          ? 'current' as const 
          : new Date() >= roundEndTime 
            ? 'completed' as const 
            : 'upcoming' as const
      });
    });
    
    // Update the schedule
    setSchedule(newSchedule);
    setFullScheduleDialogOpen(false);
    
    // Show success message
    setSuccessMessage('New schedule generated successfully');
    setTimeout(() => setSuccessMessage(null), 3000);
  };

  // Sort schedule by start time
  const sortedSchedule = [...schedule].sort((a, b) => 
    new Date(a.startTime).getTime() - new Date(b.startTime).getTime()
  );

  // Group schedule by table for the admin grid view
  const tableScheduleMap: Record<number, ScheduleItem[]> = {};
  sortedSchedule.forEach(item => {
    if (!tableScheduleMap[item.tableNumber]) {
      tableScheduleMap[item.tableNumber] = [];
    }
    tableScheduleMap[item.tableNumber].push(item);
  });
  
  // Get all tables
  const tables = Object.keys(tableScheduleMap).map(Number).sort((a, b) => a - b);

  // Handle adjusting round time in schedule management 
  const handleAdjustRoundTime = (index: number) => {
    const round = sortedSchedule[index];
    setSelectedRoundIndex(index);
    setAdjustTimeValue(new Date(round.startTime));
    setAdjustTimeDialogOpen(true);
  };

  // Apply the adjusted time to the schedule
  const handleApplyTimeAdjustment = () => {
    if (selectedRoundIndex < 0 || !adjustTimeValue) return;
    
    const updatedSchedule = [...schedule];
    const selectedRound = updatedSchedule[selectedRoundIndex];
    
    // Calculate time difference between original and new start time
    const oldStartTime = new Date(selectedRound.startTime);
    const newStartTime = new Date(adjustTimeValue);
    const timeDiff = newStartTime.getTime() - oldStartTime.getTime();
    
    // Round duration remains the same
    const roundDuration = new Date(selectedRound.endTime).getTime() - oldStartTime.getTime();
    
    // Update selected round
    updatedSchedule[selectedRoundIndex] = {
      ...selectedRound,
      startTime: newStartTime.toISOString(),
      endTime: new Date(newStartTime.getTime() + roundDuration).toISOString()
    };
    
    // If we're shifting all subsequent rounds, update them too
    if (shiftMode === 'all_subsequent') {
      for (let i = selectedRoundIndex + 1; i < updatedSchedule.length; i++) {
        const round = updatedSchedule[i];
        const roundStartTime = new Date(round.startTime).getTime();
        const roundEndTime = new Date(round.endTime).getTime();
        const roundDuration = roundEndTime - roundStartTime;
        
        // Shift by the same time difference
        const newStart = new Date(roundStartTime + timeDiff);
        const newEnd = new Date(newStart.getTime() + roundDuration);
        
        updatedSchedule[i] = {
          ...round,
          startTime: newStart.toISOString(),
          endTime: newEnd.toISOString()
        };
      }
    }
    
    // Update the schedule
    setSchedule(updatedSchedule);
    setAdjustTimeDialogOpen(false);
    setSuccessMessage(shiftMode === 'all_subsequent' 
      ? 'Round time adjusted and all subsequent rounds shifted'
      : 'Round time adjusted');
    setTimeout(() => setSuccessMessage(null), 3000);
  };

  // Handle pause/resume from the schedule management dialog
  const handleSchedulePauseResume = (index: number) => {
    const round = sortedSchedule[index];
    
    if (round.status === 'current') {
      // Pause the round
      handlePauseRound(round.id);
    } else if (round.status === 'paused') {
      // Resume the round, which will shift subsequent rounds
      handleResumeRound(round.id);
    }
  };

  // Add new function to format countdown time nicely
  const formatCountdown = (seconds: number): string => {
    if (seconds < 0) return '0s';
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    
    if (hours > 0) {
      return `${hours}h ${minutes}m ${remainingSeconds}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${remainingSeconds}s`;
    } else {
      return `${remainingSeconds}s`;
    }
  };

  // Find upcoming rounds for the current user
  const getAttendeeRounds = (): {current: ScheduleItem | null, next: ScheduleItem | null} => {
    if (!user) return {current: null, next: null};
    
    // Find rounds where the current user is a participant
    const userRounds = sortedSchedule.filter(
      item => item.participant1Id === user.id || item.participant2Id === user.id
    );
    
    // Find current and next rounds
    const currentRoundItem = userRounds.find(item => item.status === 'current');
    // Convert undefined to null for consistency
    const currentRound = currentRoundItem || null;
    
    const upcomingRounds = userRounds
      .filter(item => item.status === 'upcoming')
      .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime());
    
    const nextRound = upcomingRounds.length > 0 ? upcomingRounds[0] : null;
    
    return {current: currentRound, next: nextRound};
  };

  // Get the participant ID of the user's partner in a round
  const getPartnerIdForUser = (round: ScheduleItem | null): string | null => {
    if (!round || !user) return null;
    
    if (round.participant1Id === user.id) {
      return round.participant2Id;
    } else if (round.participant2Id === user.id) {
      return round.participant1Id;
    }
    
    return null;
  };

  // Add a function to handle ending the event
  const handleEndEvent = async () => {
    if (!eventId) return;
    
    try {
      // First save all matches and schedule data
      const matchData = await eventsApi.getEventMatches(eventId);
      const scheduleData = schedule;
      
      // Calculate final compatibility scores based on completed rounds
      const finalMatches = matchData.map((match: Match) => {
        // Find all completed rounds between these participants
        const completedRounds = scheduleData.filter(round => 
          round.status === 'completed' && 
          ((round.participant1Id === match.participant1Id && round.participant2Id === match.participant2Id) ||
           (round.participant1Id === match.participant2Id && round.participant2Id === match.participant1Id))
        );
        
        // Update compatibility score based on completed rounds
        return {
          ...match,
          compatibilityScore: completedRounds.length > 0 ? match.compatibilityScore * 1.2 : match.compatibilityScore
        };
      });
      
      // Save final matches to database
      await eventsApi.saveFinalMatches(eventId, finalMatches);
      
      // Schedule post-event matching notification (4 hours after event)
      const eventEndTime = new Date();
      const matchingNotificationTime = new Date(eventEndTime.getTime() + (4 * 60 * 60 * 1000)); // 4 hours later
      
      await eventsApi.scheduleMatchingNotification(eventId, matchingNotificationTime.toISOString());
      
      // Complete the event
      await eventsApi.completeEvent(eventId);
      
      // Refresh events to update the UI
      await refreshEvents();
      
      setSuccessMessage('Event ended successfully. Participants will be notified about matches in 4 hours.');
      
      // Navigate after a longer delay to ensure UI updates are visible
      setTimeout(() => {
        navigate('/events');
      }, 2000);
    } catch (err: any) {
      setError(err.message || 'Failed to end event');
    }
  };

  // Loading state
  if (loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" p={4}>
        <CircularProgress size={60} />
        <Typography variant="h6" sx={{ ml: 2 }}>
          {isNewEvent ? 'Generating event schedule...' : 'Loading event data...'}
        </Typography>
      </Box>
    );
  }
  
  // Error state
  if (error) {
    return (
      <Box p={3}>
        <Alert severity="error">{error}</Alert>
        <Box sx={{ mt: 2, display: 'flex', gap: 2 }}>
          <Button 
            startIcon={<ArrowBackIcon />} 
            onClick={() => navigate('/events')} 
            variant="outlined"
          >
            Back to Events
          </Button>
          {error.includes('completed') && (
            <Button 
              color="primary"
              variant="contained"
              onClick={() => {
                // Navigate to events page with archive tab selected (index 2)
                navigate('/events');
                // Set a flag in sessionStorage to open the archive tab
                sessionStorage.setItem('openEventsTab', '2');
              }}
            >
              View Archive
            </Button>
          )}
        </Box>
      </Box>
    );
  }
  
  // No event found state
  if (!event) {
    return (
      <Box p={3}>
        <Alert severity="warning">Event not found</Alert>
        <Button 
          startIcon={<ArrowBackIcon />} 
          onClick={() => navigate('/events')} 
          sx={{ mt: 2 }}
        >
          Back to Events
        </Button>
      </Box>
    );
  }

  return (
    <Container maxWidth="lg" sx={{ mb: 4 }}>
      {/* Admin helper alert */}
      {checkIsAdmin() || checkIsOrganizer() ? (
        <Alert 
          severity="info" 
          sx={{ mb: 3, mt: 2 }}
          action={
            <Button 
              color="inherit" 
              size="small"
              onClick={() => navigate(`/events/${eventId}/check-in`)}
            >
              MANAGE CHECK-IN
            </Button>
          }
        >
          As an admin, you can view the full event schedule, manage participants, and handle check-ins.
        </Alert>
      ) : null}

      <Box p={3}>
        {/* Header & Navigation Buttons */}
        <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 4 }}>
          <Typography variant="h4" component="h1" gutterBottom>
            {event ? event.name : 'Live Event'}
          </Typography>
          <Box sx={{ display: 'flex', gap: 2 }}>
            <Button startIcon={<ArrowBackIcon />} onClick={() => navigate('/events')}>
              Back
            </Button>
            <Button 
              startIcon={<TableIcon />} 
              onClick={() => navigate(`/events/${eventId}/schedule`)}
              variant="outlined"
            >
              View Schedule
            </Button>
            {(checkIsAdmin() || checkIsOrganizer()) && (
              <Button 
                startIcon={<PeopleIcon />} 
                onClick={() => navigate(`/events/${eventId}/participants`)}
                variant="contained"
              >
                Manage Users
              </Button>
            )}
          </Box>
        </Box>

        {/* Main Content */}
        <Box p={3}>
          {/* Header */}
          <Box display="flex" alignItems="center" mb={3}>
            <Button 
              startIcon={<ArrowBackIcon />} 
              onClick={() => navigate('/events')} 
              sx={{ mr: 2 }}
            >
              Back
            </Button>
            <Typography variant="h4">
              {event?.name}
              <Chip 
                label="LIVE" 
                color="error" 
                size="small" 
                sx={{ ml: 2, fontWeight: 'bold' }} 
              />
            </Typography>
            <Box sx={{ ml: 'auto', display: 'flex', gap: 2 }}>
              {/* Schedule Button for everyone */}
              <Button
                variant="outlined"
                color="primary"
                startIcon={<TableIcon />}
                onClick={() => navigate(`/events/${eventId}/schedule`)}
              >
                View Schedule
              </Button>
              
              {checkIsAdmin() && (
                <Button 
                  variant="outlined"
                  startIcon={<SupervisorAccountIcon />}
                  onClick={() => navigate('/admin/users')}
                >
                  Manage Users
                </Button>
              )}
              {canManageEvent && (
                <Button
                  variant="contained"
                  color="error"
                  onClick={() => {
                    if (window.confirm('Are you sure you want to end this event? This action cannot be undone.')) {
                      // Call API to end event
                      handleEndEvent();
                    }
                  }}
                >
                  End Event
                </Button>
              )}
            </Box>
          </Box>
          
          {/* Success message */}
          {successMessage && (
            <Alert severity="success" sx={{ mb: 3 }}>
              {successMessage}
            </Alert>
          )}
          
          {/* Event Info Card */}
          <Paper elevation={2} sx={{ mb: 3, p: 3 }}>
            <Grid container spacing={2}>
              <Grid item xs={12} md={8}>
                <Typography variant="h5" gutterBottom>{event.name}</Typography>
                <Typography variant="body1" color="text.secondary">
                  {new Date(event.starts_at).toLocaleDateString()} {formatTime(event.starts_at)} - {formatTime(event.ends_at)}
                </Typography>
                <Typography variant="body2">Location: {event.address}</Typography>
              </Grid>
              <Grid item xs={12} md={4} sx={{ display: 'flex', alignItems: 'center', justifyContent: 'flex-end' }}>
                <Stack direction="row" spacing={1}>
                  <Chip 
                    icon={<CheckIcon />}
                    label={`${participants.length} Checked In`} 
                    color="success" 
                  />
                  <Chip 
                    icon={<TableIcon />}
                    label={`${schedule.length} Rounds`} 
                    color="primary" 
                  />
                  {canManageEvent && (
                    <Button
                      variant="outlined"
                      startIcon={<SettingsIcon />}
                      size="small"
                      onClick={() => setFullScheduleDialogOpen(true)}
                    >
                      Manage Schedule
                    </Button>
                  )}
                </Stack>
              </Grid>
            </Grid>
          </Paper>
          
          {/* Current Round Status Card */}
          <Paper elevation={3} sx={{ mb: 4, p: 3, bgcolor: 'background.paper', borderRadius: 2 }}>
            <Grid container spacing={3}>
              {!canManageEvent ? (
                // Attendee View
                <Grid item xs={12}>
                  {(() => {
                    const { current, next } = getAttendeeRounds();
                    const currentPartnerId = getPartnerIdForUser(current);
                    const nextPartnerId = getPartnerIdForUser(next);
                    
                    return (
                      <>
                        <Typography variant="h6" gutterBottom color="primary">
                          Your Schedule
                        </Typography>
                        {current && (
                          <Box sx={{ mb: 3 }}>
                            <Typography variant="subtitle1" color="primary">Current Round</Typography>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                              <PersonIcon color="primary" />
                              <Typography>
                                Round {sortedSchedule.findIndex(item => item.id === current.id) + 1} with {currentPartnerId ? getParticipantName(currentPartnerId) : 'None'}
                              </Typography>
                              <Chip size="small" label={`Table ${current.tableNumber}`} color="primary" />
                            </Box>
                            <Typography variant="body2" color="text.secondary">
                              {timeRemaining}
                            </Typography>
                            <LinearProgress 
                              variant="determinate" 
                              value={progressPercent} 
                              sx={{ height: 8, borderRadius: 2, mt: 1 }} 
                            />
                          </Box>
                        )}
                        {next && (
                          <Box sx={{ mb: 3 }}>
                            <Typography variant="subtitle1" color="primary">Next Round</Typography>
                            <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                              <PersonIcon color="primary" />
                              <Typography>
                                Round {sortedSchedule.findIndex(item => item.id === next.id) + 1} with {nextPartnerId ? getParticipantName(nextPartnerId) : 'None'}
                              </Typography>
                              <Chip size="small" label={`Table ${next.tableNumber}`} color="primary" variant="outlined" />
                            </Box>
                            <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                              Starts at {formatTime(next.startTime)}
                            </Typography>
                          </Box>
                        )}
                        {!current && !next && (
                          <Alert severity="info">
                            You have no active or upcoming rounds scheduled.
                          </Alert>
                        )}
                      </>
                    );
                  })()}
                </Grid>
              ) : (
                // Admin/Organizer View (existing code)
                <>
                  <Grid item xs={12} md={6}>
                    <Typography variant="h6" gutterBottom color="primary">
                      Current Round {currentRound?.status === 'paused' && <Chip size="small" label="PAUSED" color="warning" sx={{ ml: 1 }} />}
                    </Typography>
                    
                    {currentRound ? (
                      <>
                        <Box sx={{ mb: 2 }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                            <PersonIcon color="primary" />
                            <Typography variant="body1" color="text.primary">
                              {getParticipantName(currentRound.participant1Id)} & {getParticipantName(currentRound.participant2Id)}
                            </Typography>
                          </Box>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            <TimeIcon color="primary" />
                            <Typography variant="body2" color="text.secondary">
                              {formatTime(currentRound.startTime)} - {formatTime(currentRound.endTime)}
                            </Typography>
                            <Chip 
                              size="small" 
                              label={`Table ${currentRound.tableNumber}`}
                              color="primary"
                              icon={<TableIcon />}
                              sx={{ ml: 1 }}
                            />
                          </Box>
                        </Box>
                        
                        <Box sx={{ mt: 3 }}>
                          <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                            <Typography variant="body2" color="text.primary">
                              {currentRound.status === 'paused' ? 'Paused' : timeRemaining}
                            </Typography>
                            <Typography variant="body2" color="primary">
                              {progressPercent}%
                            </Typography>
                          </Box>
                          <LinearProgress 
                            variant="determinate" 
                            value={progressPercent} 
                            sx={{ height: 8, borderRadius: 2 }} 
                            color={currentRound.status === 'paused' ? 'warning' : 'success'}
                          />
                        </Box>
                      </>
                    ) : (
                      <Box sx={{ p: 2, bgcolor: 'background.default', borderRadius: 1 }}>
                        <Typography sx={{ color: 'text.primary', fontWeight: 'medium' }}>
                          No active round at the moment. {nextRound && `Next round starts in ${timeRemaining}`}
                        </Typography>
                      </Box>
                    )}
                  </Grid>
                  
                  <Grid item xs={12} md={6}>
                    <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start' }}>
                      <Typography variant="h6" gutterBottom color="primary">
                        Next Round
                      </Typography>
                      {canManageEvent && nextRound && (
                        <IconButton 
                          size="small" 
                          onClick={() => handleEditRound(nextRound)}
                          color="primary"
                        >
                          <EditIcon />
                        </IconButton>
                      )}
                    </Box>
                    
                    {nextRound ? (
                      <>
                        <Box sx={{ mb: 2 }}>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 1 }}>
                            <PersonIcon color="primary" />
                            <Typography variant="body1" color="text.primary">
                              {getParticipantName(nextRound.participant1Id)} & {getParticipantName(nextRound.participant2Id)}
                            </Typography>
                          </Box>
                          <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                            <TimeIcon color="primary" />
                            <Typography variant="body2" color="text.secondary">
                              {formatTime(nextRound.startTime)} - {formatTime(nextRound.endTime)}
                            </Typography>
                            <Chip 
                              size="small" 
                              label={`Table ${nextRound.tableNumber}`}
                              variant="outlined"
                              color="primary"
                              icon={<TableIcon />}
                              sx={{ ml: 1 }}
                            />
                          </Box>
                        </Box>
                        
                        {!currentRound && (
                          <Box sx={{ mt: 3, p: 2, bgcolor: 'primary.dark', color: 'primary.contrastText', borderRadius: 1 }}>
                            <Typography variant="body2" fontWeight="medium">
                              Starts in: {timeRemaining}
                            </Typography>
                            {canManageEvent && (
                              <Button 
                                variant="contained" 
                                size="small" 
                                color="primary"
                                onClick={() => handleEditRound(nextRound)}
                                sx={{ mt: 1 }}
                              >
                                Adjust Time
                              </Button>
                            )}
                          </Box>
                        )}
                      </>
                    ) : (
                      <Box sx={{ p: 2, bgcolor: 'background.default', borderRadius: 1 }}>
                        <Typography sx={{ color: 'text.primary' }}>
                          {schedule.every(item => item.status === 'completed' || item.status === 'current') 
                            ? 'All rounds completed or in progress' 
                            : 'No upcoming rounds scheduled'}
                        </Typography>
                      </Box>
                    )}
                  </Grid>
                  
                  {canManageEvent && currentRound && (
                    <Grid item xs={12} sx={{ mt: 2, display: 'flex', justifyContent: 'flex-end', gap: 2 }}>
                      {currentRound.status === 'paused' ? (
                        <Button
                          variant="contained"
                          color="success"
                          startIcon={<PlayIcon />}
                          onClick={() => handleResumeRound(currentRound.id)}
                        >
                          Resume Round
                        </Button>
                      ) : (
                        <Button
                          variant="contained"
                          color="warning"
                          startIcon={<PauseIcon />}
                          onClick={() => handlePauseRound(currentRound.id)}
                        >
                          Pause Round
                        </Button>
                      )}
                      <Button
                        variant="outlined"
                        startIcon={<EditIcon />}
                        onClick={() => handleEditRound(currentRound)}
                      >
                        Edit Times
                      </Button>
                    </Grid>
                  )}
                </>
              )}
            </Grid>
          </Paper>
          
          {/* Schedule View Controls */}
          <Box sx={{ mb: 2, display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
            <Typography variant="h5" color="primary">
              Event Schedule
            </Typography>
            <Box>
              <IconButton 
                color={viewMode === 'list' ? 'primary' : 'default'}
                onClick={() => setViewMode('list')}
              >
                <ViewListIcon />
              </IconButton>
              <IconButton 
                color={viewMode === 'grid' ? 'primary' : 'default'}
                onClick={() => setViewMode('grid')}
              >
                <ViewModuleIcon />
              </IconButton>
            </Box>
          </Box>
          
          {/* List View Schedule */}
          {viewMode === 'list' && (
            <TableContainer component={Paper} sx={{ bgcolor: 'background.paper', borderRadius: 2 }}>
              <Table>
                <TableHead>
                  <TableRow>
                    <TableCell>Round</TableCell>
                    <TableCell>Time</TableCell>
                    <TableCell>Participant 1</TableCell>
                    <TableCell>Participant 2</TableCell>
                    <TableCell>Table</TableCell>
                    <TableCell>Status</TableCell>
                    {canManageEvent && <TableCell sx={{ color: 'primary.main', fontWeight: 'bold' }}>Actions</TableCell>}
                  </TableRow>
                </TableHead>
                <TableBody>
                  {sortedSchedule.map((item, index) => (
                    <TableRow 
                      key={item.id}
                      sx={{ 
                        bgcolor: item.status === 'current' 
                          ? 'success.dark' 
                          : (item.status === 'completed' 
                            ? 'action.hover' 
                            : (item.status === 'paused' ? 'warning.dark' : 'inherit')),
                        '&:hover': { bgcolor: 'action.hover' }
                      }}
                    >
                      <TableCell sx={{ color: 'text.primary' }}>
                        Round {index + 1}
                      </TableCell>
                      <TableCell sx={{ color: 'text.primary' }}>
                        {formatTime(item.startTime)} - {formatTime(item.endTime)}
                      </TableCell>
                      <TableCell sx={{ color: 'text.primary' }}>{getParticipantName(item.participant1Id)}</TableCell>
                      <TableCell sx={{ color: 'text.primary' }}>{getParticipantName(item.participant2Id)}</TableCell>
                      <TableCell>
                        <Chip 
                          icon={<SeatIcon />}
                          label={`Table ${item.tableNumber}`}
                          size="small"
                          color={item.status === 'current' ? 'success' : 'default'}
                        />
                      </TableCell>
                      <TableCell>
                        <Chip 
                          icon={item.status === 'paused' ? <PauseIcon /> : getStatusIcon(item.status)}
                          label={item.status.toUpperCase()}
                          color={getStatusColor(item.status)}
                          size="small"
                        />
                      </TableCell>
                      {canManageEvent && (
                        <TableCell>
                          <Stack direction="row" spacing={1}>
                            {item.status === 'current' && (
                              <Tooltip title="Pause Round">
                                <IconButton 
                                  size="small" 
                                  onClick={() => handlePauseRound(item.id)}
                                  color="warning"
                                >
                                  <PauseIcon />
                                </IconButton>
                              </Tooltip>
                            )}
                            {item.status === 'paused' && (
                              <Tooltip title="Resume Round">
                                <IconButton 
                                  size="small" 
                                  onClick={() => handleResumeRound(item.id)}
                                  color="success"
                                >
                                  <PlayIcon />
                                </IconButton>
                              </Tooltip>
                            )}
                            <Tooltip title="Edit Times">
                              <IconButton 
                                size="small" 
                                onClick={() => handleEditRound(item)}
                                color="primary"
                              >
                                <EditIcon />
                              </IconButton>
                            </Tooltip>
                          </Stack>
                        </TableCell>
                      )}
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </TableContainer>
          )}
          
          {/* Grid View for Admins - Tables with Timeline */}
          {viewMode === 'grid' && canManageEvent && (
            <Grid container spacing={2}>
              {tables.map(tableNum => (
                <Grid item xs={12} md={6} lg={4} key={`table-${tableNum}`}>
                  <Card sx={{ bgcolor: 'background.paper', borderRadius: 2 }}>
                    <CardContent>
                      <Typography variant="h6" gutterBottom sx={{ display: 'flex', alignItems: 'center', color: 'primary.main' }}>
                        <TableIcon sx={{ mr: 1 }} /> Table {tableNum}
                      </Typography>
                      
                      <Divider sx={{ mb: 2 }} />
                      
                      <Stack spacing={2}>
                        {tableScheduleMap[tableNum]
                          .sort((a, b) => new Date(a.startTime).getTime() - new Date(b.startTime).getTime())
                          .map((item, roundIndex) => {
                            // Find the overall index of this item in the sortedSchedule
                            const overallIndex = sortedSchedule.findIndex(s => s.id === item.id);
                            
                            return (
                              <Box 
                                key={item.id} 
                                sx={{ 
                                  p: 2, 
                                  borderRadius: 1,
                                  bgcolor: item.status === 'current' 
                                    ? 'success.dark' 
                                    : (item.status === 'completed' 
                                      ? 'action.hover' 
                                      : (item.status === 'paused' ? 'warning.dark' : 'primary.dark')),
                                  color: 'text.primary'
                                }}
                              >
                                <Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 1 }}>
                                  <Typography variant="subtitle2" color="text.primary">
                                    Round {overallIndex + 1}: {formatTime(item.startTime)} - {formatTime(item.endTime)}
                                  </Typography>
                                  <Chip 
                                    label={item.status.toUpperCase()}
                                    size="small"
                                    color={getStatusColor(item.status)}
                                  />
                                </Box>
                                
                                <Typography variant="body2" color="text.primary">
                                  {getParticipantName(item.participant1Id)} & {getParticipantName(item.participant2Id)}
                                </Typography>
                                
                                <Box sx={{ display: 'flex', justifyContent: 'flex-end', mt: 1 }}>
                                  {item.status === 'current' && (
                                    <IconButton 
                                      size="small" 
                                      onClick={() => handlePauseRound(item.id)}
                                      color="warning"
                                      sx={{ bgcolor: 'action.hover' }}
                                    >
                                      <PauseIcon fontSize="small" />
                                    </IconButton>
                                  )}
                                  {item.status === 'paused' && (
                                    <IconButton 
                                      size="small" 
                                      onClick={() => handleResumeRound(item.id)}
                                      color="success"
                                      sx={{ bgcolor: 'action.hover' }}
                                    >
                                      <PlayIcon fontSize="small" />
                                    </IconButton>
                                  )}
                                  <IconButton 
                                    size="small" 
                                    onClick={() => handleEditRound(item)}
                                    color="primary"
                                    sx={{ bgcolor: 'action.hover' }}
                                  >
                                    <EditIcon fontSize="small" />
                                  </IconButton>
                                </Box>
                              </Box>
                            );
                          })}
                      </Stack>
                    </CardContent>
                  </Card>
                </Grid>
              ))}
            </Grid>
          )}
          
          {/* Edit Single Round Dialog */}
          <Dialog open={editDialogOpen} onClose={() => setEditDialogOpen(false)}>
            <DialogTitle>Edit Round Times</DialogTitle>
            <DialogContent sx={{ minWidth: 400 }}>
              <Box mt={2}>
                <Typography variant="subtitle1" gutterBottom>
                  Participants: {selectedRound && (
                    <>{getParticipantName(selectedRound.participant1Id)} & {getParticipantName(selectedRound.participant2Id)}</>
                  )}
                </Typography>
                <Typography variant="subtitle2" gutterBottom>
                  Table: {selectedRound?.tableNumber}
                </Typography>
                
                <LocalizationProvider dateAdapter={AdapterDateFns}>
                  <Box mt={3} mb={2}>
                    <DateTimePicker
                      label="Start Time"
                      value={editStartTime}
                      onChange={(newValue) => setEditStartTime(newValue)}
                      slotProps={{
                        textField: { 
                          fullWidth: true, 
                          margin: 'normal',
                          variant: 'outlined'
                        }
                      }}
                    />
                  </Box>
                  
                  <Box mt={2} mb={3}>
                    <DateTimePicker
                      label="End Time"
                      value={editEndTime}
                      onChange={(newValue) => setEditEndTime(newValue)}
                      slotProps={{
                        textField: { 
                          fullWidth: true, 
                          margin: 'normal',
                          variant: 'outlined'
                        }
                      }}
                    />
                  </Box>
                </LocalizationProvider>
              </Box>
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setEditDialogOpen(false)}>Cancel</Button>
              <Button 
                onClick={handleSaveRoundTimes} 
                variant="contained" 
                color="primary"
                disabled={!editStartTime || !editEndTime}
              >
                Save Changes
              </Button>
            </DialogActions>
          </Dialog>
          
          {/* Full Schedule Management Dialog */}
          <Dialog 
            open={fullScheduleDialogOpen} 
            onClose={() => setFullScheduleDialogOpen(false)}
            maxWidth="md"
            fullWidth
          >
            <DialogTitle>Manage Complete Schedule</DialogTitle>
            <DialogContent>
              <Box mt={2}>
                <Typography variant="subtitle1" gutterBottom>
                  Event: {event.name}
                </Typography>
                
                <Box sx={{ mb: 3, mt: 3 }}>
                  <Typography variant="h6" gutterBottom>
                    Schedule Settings
                  </Typography>
                  <Grid container spacing={2}>
                    <Grid item xs={12} sm={6}>
                      <TextField
                        label="Round Duration (minutes)"
                        type="number"
                        value={scheduleDuration}
                        onChange={(e) => setScheduleDuration(parseInt(e.target.value) || 5)}
                        fullWidth
                        inputProps={{ min: 1, max: 60 }}
                      />
                    </Grid>
                    <Grid item xs={12} sm={6}>
                      <TextField
                        label="Break Duration (minutes)"
                        type="number"
                        value={breakDuration}
                        onChange={(e) => setBreakDuration(parseInt(e.target.value) || 2)}
                        fullWidth
                        inputProps={{ min: 0, max: 30 }}
                      />
                    </Grid>
                  </Grid>
                  
                  <Alert severity="info" sx={{ mt: 2 }}>
                    <Typography variant="body2">
                      Generating a new schedule will use the following constraints:
                    </Typography>
                    <ul>
                      <li>Only checked-in participants will be included ({participants.length} people)</li>
                      <li>Each round will last {scheduleDuration} minutes with {breakDuration} minute breaks</li>
                      <li>Tables will be assigned automatically</li>
                    </ul>
                  </Alert>
                  
                  <Box sx={{ display: 'flex', justifyContent: 'center', mt: 3 }}>
                    <Button
                      variant="contained"
                      color="primary"
                      onClick={handleGenerateNewSchedule}
                      disabled={participants.length < 2}
                      startIcon={<TableIcon />}
                    >
                      Generate New Schedule
                    </Button>
                  </Box>
                </Box>
                
                <Divider sx={{ my: 3 }} />
                
                <Typography variant="h6" gutterBottom>
                  Current Schedule ({sortedSchedule.length} rounds)
                </Typography>
                
                <TableContainer>
                  <Table size="small">
                    <TableHead>
                      <TableRow>
                        <TableCell>Round</TableCell>
                        <TableCell>Time</TableCell>
                        <TableCell>Participants</TableCell>
                        <TableCell>Table</TableCell>
                        <TableCell>Status</TableCell>
                        <TableCell>Actions</TableCell>
                      </TableRow>
                    </TableHead>
                    <TableBody>
                      {sortedSchedule.map((item, index) => (
                        <TableRow key={item.id}>
                          <TableCell>{index + 1}</TableCell>
                          <TableCell>
                            {formatTime(item.startTime)} - {formatTime(item.endTime)}
                          </TableCell>
                          <TableCell>
                            {getParticipantName(item.participant1Id)} & {getParticipantName(item.participant2Id)}
                          </TableCell>
                          <TableCell>
                            {item.tableNumber}
                          </TableCell>
                          <TableCell>
                            <Chip 
                              label={item.status.toUpperCase()}
                              size="small"
                              color={getStatusColor(item.status)}
                            />
                          </TableCell>
                          <TableCell>
                            <Stack direction="row" spacing={1}>
                              <Tooltip title="Adjust Start Time">
                                <IconButton
                                  size="small"
                                  onClick={() => handleAdjustRoundTime(index)}
                                  color="primary"
                                >
                                  <EditIcon fontSize="small" />
                                </IconButton>
                              </Tooltip>
                              {item.status === 'current' && (
                                <Tooltip title="Pause Round">
                                  <IconButton
                                    size="small"
                                    onClick={() => handleSchedulePauseResume(index)}
                                    color="warning"
                                  >
                                    <PauseIcon fontSize="small" />
                                  </IconButton>
                                </Tooltip>
                              )}
                              {item.status === 'paused' && (
                                <Tooltip title="Resume Round & Shift Subsequent Rounds">
                                  <IconButton
                                    size="small"
                                    onClick={() => handleSchedulePauseResume(index)}
                                    color="success"
                                  >
                                    <PlayIcon fontSize="small" />
                                  </IconButton>
                                </Tooltip>
                              )}
                            </Stack>
                          </TableCell>
                        </TableRow>
                      ))}
                    </TableBody>
                  </Table>
                </TableContainer>
              </Box>
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setFullScheduleDialogOpen(false)}>Close</Button>
            </DialogActions>
          </Dialog>

          {/* Time Adjustment Dialog */}
          <Dialog open={adjustTimeDialogOpen} onClose={() => setAdjustTimeDialogOpen(false)}>
            <DialogTitle>Adjust Round Start Time</DialogTitle>
            <DialogContent sx={{ minWidth: 350 }}>
              {selectedRoundIndex >= 0 && sortedSchedule[selectedRoundIndex] && (
                <Box my={2}>
                  <Typography variant="subtitle1" gutterBottom>
                    Round {selectedRoundIndex + 1}
                  </Typography>
                  <Typography variant="body2" gutterBottom>
                    Participants: {getParticipantName(sortedSchedule[selectedRoundIndex].participant1Id)} & {getParticipantName(sortedSchedule[selectedRoundIndex].participant2Id)}
                  </Typography>
                  <Typography variant="body2" gutterBottom mb={3}>
                    Current time: {formatTime(sortedSchedule[selectedRoundIndex].startTime)} - {formatTime(sortedSchedule[selectedRoundIndex].endTime)}
                  </Typography>
                  
                  <LocalizationProvider dateAdapter={AdapterDateFns}>
                    <DateTimePicker
                      label="New Start Time"
                      value={adjustTimeValue}
                      onChange={(newValue) => setAdjustTimeValue(newValue)}
                      slotProps={{
                        textField: { 
                          fullWidth: true, 
                          margin: 'normal',
                          variant: 'outlined'
                        }
                      }}
                    />
                  </LocalizationProvider>
                  
                  <FormControl component="fieldset" sx={{ mt: 3 }}>
                    <Typography variant="subtitle2" gutterBottom>
                      Adjustment Mode:
                    </Typography>
                    <RadioGroup
                      value={shiftMode}
                      onChange={(e) => setShiftMode(e.target.value as 'single' | 'all_subsequent')}
                    >
                      <FormControlLabel
                        value="single"
                        control={<Radio />}
                        label="Adjust only this round"
                      />
                      <FormControlLabel
                        value="all_subsequent"
                        control={<Radio />}
                        label="Adjust this round and shift all subsequent rounds"
                      />
                    </RadioGroup>
                  </FormControl>
                </Box>
              )}
            </DialogContent>
            <DialogActions>
              <Button onClick={() => setAdjustTimeDialogOpen(false)}>Cancel</Button>
              <Button 
                onClick={handleApplyTimeAdjustment} 
                variant="contained" 
                color="primary"
                disabled={!adjustTimeValue}
              >
                Apply Change
              </Button>
            </DialogActions>
          </Dialog>
        </Box>
      </Container>
    );
  };

  export default LiveEventView; 